---
title: "Applied Epi - Heat plots, epicurves, and pyramids"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
library(ggplot2)
library(tidyverse)
library(viridis)

knitr::opts_chunk$set(echo = FALSE)
linelist <- rio::import(system.file("dat/linelist_combined_20141201.rds", package = "introexercises"))

linelist$hospital <- factor(linelist$hospital)

#Create an easy heatmap dataset
hospital_week_raw <- linelist %>%
  group_by(hospital, week_onset) %>%
  summarise(n = n())

expanded_weeks <- hospital_week_raw %>% 
  select(hospital, week_onset) %>%
  ungroup() %>%
  tidyr::expand(., week_onset, hospital)

hospital_week_expanded <- hospital_week_raw %>%      
  right_join(expanded_weeks) %>%                            
  mutate(n = replace_na(n, 0))  

hospital_week <- subset(hospital_week_expanded, week_onset >= "2014-06-15")

count_data <- linelist %>% 
  group_by(hospital, date_hospitalisation) %>% 
  summarize(n_cases = dplyr::n()) %>% 
  ungroup()

```

# Advanced ggplot2 - Heatmaps, Epi curves and Age pyramids

## Welcome

Welcome to the advanced ggplot2 module where we will be learning how to code and customise more advanced plots such as heatmaps, epi curves and age pyramids. We will be building on what you have learned previously from tidyverse and ggplot2 to produce these.

This will involve using previously explored aspects such as `ggplot()`, pipe chains `%>%`, themes (e.g. `theme_minimal()`, `theme_bw()`), custom axis scales (e.g. `scale_y_continuous()`) and new functions such as `geom_tile()` for heatmaps, `incidence` (from **incidence2**) and `geom_histogram()` for epi curves, and `age_pyramid` (from **apyramid**) for age pyramids.

But first, let us refresh ourselves on the basics of **ggplot2**!

```{r quiz1}
quiz(
  question("Where are dynamic aesthetics placed in ggplot code?",
    answer("inside aes()", correct = T),
    answer("outside aes()")
  ),
  question("Are static aesthetics in the initial ggplot() call inherited by subsequent geoms?",
    answer("No", correct = TRUE),
    answer("Yes")
  ),
  question("Are dynamic aesthetics in the initial ggplot() call inherited by subsequent geoms?",
    answer("No"),
    answer("Yes", correct = TRUE)
  ),
    question("Should adjustments to the theme be made before or after setting one of the default themes?",
    answer("before"),
    answer("after", correct = TRUE)
  ),
  question("Which of the following are prebuilt themes in ggplot",
    answer("theme_bw()", correct = TRUE),
    answer("theme_classic()", correct = TRUE),
    answer("theme_red()"),
    answer("scale_color_brewer()")
  ),
  question("How would you hide a legend in ggplot?",
    answer("theme(legend.title = 'element.blank()')"),
    answer("theme(legend.position = 'right')"),
    answer("theme(legend.position(`none`))"),
    answer("theme(legend.position = 'none')", correct = TRUE)
  ),
  question("How would you set your legend to appear in the centre of your graph?",
    answer("theme(legend.position = 'middle')"),
    answer("theme(legend.position =  c(0.5,0.5))", correct = TRUE)
  )
)
```

Great, now we have refreshed our memory with a quiz, we will start on our first topic, *heatmaps*.

## Heatmaps

Heatmaps, also called heat plots and heat tiles, are useful visualizations when trying to display 3 variables (x-axis, y-axis and fill). For instance, you might want to look at a breakdown of how many cases were reported by week across a hospitals to get an idea of how the epidemic is/has progressed.

We have a dataset called `hospital_week`, which has columns labelling the hospital, the week of onset and the number of these in the week. Use `head()` to look at the data.

`r fontawesome::fa("terminal", fill = "black")` With the aid of the help function `?geom_tile` can you create a heatmap that has the week of onset on the x-axis, the hospital on the y-axis and is colored by the number of onsets in that week?

<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r eval = F, echo=T}
ggplot(data = hospital_week) +
  geom_tile(aes(x = week_onset, y = hospital, fill = n))
```
</br>
</details>

### Customising your heatmap

`r fontawesome::fa("terminal", fill = "black")` Great job, but there are still a few things we can do to refine this plot.

* Can you create a new object, `hospital_week_adjusted` where the NA values in `hospital` are recoded as "Missing", and the factors are re-ordered as "Central Hospital", "Military Hospital", "Port Hospital", "SMMH", "Other", "Missing".
* Change the color scheme to a diverging colour scale, could you provide one that goes from "skyblue" at low values to "tomato" at high values
* The axis and fill labels should be made more presentable
* The default x-axis ticks show every month, can you change these to every two weeks, and only display the day and month.

This will require a mix of refactoring the dataset, and adjusting your **ggplot** function. If you need a refresher on how to change `NA` values in factor columns, and how to reorder, checkout the R Handbook chapter on [factors](https://www.epirhandbook.com/en/factors.html?q=factor#factors).

<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r eval = F, echo=T}
hospital_week_adjusted <- hospital_week %>%
  mutate(hospital = fct_explicit_na(hospital, "Missing"),
         hospital = fct_relevel(hospital, rev(c("Central Hospital", "Military Hospital", "Port Hospital", "SMMH", "Other", "Missing"))))

ggplot(data = hospital_week_adjusted) +
  geom_tile(aes(x = week_onset, y = hospital, fill = n)) +
  scale_fill_gradient(low = "skyblue", high = "tomato") +
  labs(x = "Week onset", y = "Hospital", fill = "Number of patients with\nsymptom onset") +
  scale_x_date(date_breaks = "2 weeks", 
               date_labels = "%d %b")
```
</br>
</details>

Now you have got the hang of heatmaps and some basic customisation, we are going to move onto a harder exercise where you create the dataframe from scratch and customize the display.

Can you do the following

* Create a new object, `age_outcome_summary`, where you summarise `linelist` in order to output the percent of those in each `outcome` category when it is grouped by `age_cat` and `gender`
* Drop any `NA` values
* Once this is done, create a heatmap that is coloured by the percent of those that have an outcome of "Death" when broken down by `gender` and `age_cat`
* Clean up the axis names to "Age category", "Gender" and label to "Percent of cases fatal"
* Using the **viridis** package (`scale_fill_viridis()`) and pick a colour scheme, and set the scale limits to go from 0 to 100
* Display the percent, rounded to 1 decimal place 

<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, eval = F, echo = T}
age_outcome_summary <- linelist %>%
  drop_na(gender, age_cat) %>% #Remove the NA values
    group_by(age_cat, gender, outcome) %>% #Group by in order to summarise later
    summarise(n = n()) %>%        #Count the number in each grouping
    mutate(percent = n/sum(n) * 100) #Multiply by 100 to make the proportion into a percentage

ggplot(data = subset(age_outcome_summary, outcome == "Death")) +                 #Subset to only those with the outcome death
  geom_tile(aes(x = gender, y = age_cat, fill = percent)) +                         #Set up the mapping
  scale_fill_viridis(option = "B", limits = c(0, 100)) +                           #Choose any of the options, and set the limits to go from 0 to 100
  labs(x = "Gender", y = "Age categories", fill = "Proportion of cases fatal") +
  geom_text(
    aes(x = gender, y = age_cat, label = round(percent, 1)))


```
</br>
</details>

###
```{r quiz2}
quiz(
  question("What do you notice? Who has the lowest proportion of 'Death' as a gender and age category?",
    answer("Male and 60-69"),
    answer("Female and 0-9"),
    answer("Male and 20-29"),
    answer("Female and 40-49", correct = TRUE)
    ),
  question("Who has the highest proportion of 'Death' as a gender and age category?",
           answer("Male and 20-20", correct = TRUE),
           answer("Female and 20-29"),
           answer("Male and 50-59"),
           answer("Female and 40-49")
           ),
  question("Which gender has the oldest ages?",
           answer("Female"),
           answer("Male", correct = TRUE)
           )
)
```


Great work, you have managed to build datasets for heatmap plotting and customize these plots to produce interesting graphics you can then analyze. As with all aspects of R and ggplot, there are numerous additional ways of coding and customizing your plots to edit almost every specification you can think of. For further reading, please see the R Epidemiologists Handbook chapter on [heatmaps](https://www.epirhandbook.com/en/heat-plots.html?q=heat%20plot#heat-plots).

## Epi curves

An epidemic curve (also known as an “epi curve”) is a core epidemiological chart typically used to visualize the temporal pattern of illness onset among a cluster or epidemic of cases.

Analysis of the epicurve can reveal temporal trends, outliers, the magnitude of the outbreak, the most likely time period of exposure, time intervals between case generations, and can even help identify the mode of transmission of an unidentified disease (e.g. point source, continuous common source, person-to-person propagation).

Here we are going to look at two different ways of learning how to make epicurves

* The **incidence2** package, which can produce an epi curve with simple commands
* The **ggplot2** package, which allows for advanced customizability via more complex commands

Firstly, we will look at the **incidence2** package.

### incidence2

In order to explore epicurves, we are going to use the object `count_data`. Explore the dataframe to look at the dimensions, column names and example data.

From this, we can use the function `incidence()` from **incidence2** to produce a simple epicurve. 

Can you read the documentation of `incidence()` (`?incidence`) in order to produce a simple incidence object for the column `date_hospitalisation` with an interval of 1 week? Can you then assign this to an object `hospitalisation_week`?

<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, eval = F, echo = T}
hospitalisation_week <- incidence(linelist,
          date_index = date_hospitalisation,
          interval = "weeks")
```
</br>
</details>

Okay, now that you have made the object its time to plot. In it's simplest form, you can just type type `plot(hospitalisation_week)`
```{r, eval = T, echo = F}
plot(hospitalisation_week)
```

However, we may want to customise this output. In particular, we are not displaying potentially useful information found within `linelist`, such as age categories, or the hospital they were a patient at. Can you reform the `incidence()` object `hospitalisation_week` to additionally have the groups `age_cat` and `hospital`? 

Once you have done this, can you plot the object using `plot()` and "fill" using "hospital" in order to see how the epidemic curves differ by age category?

<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, eval = F, echo = T}
hospitalisation_week <- incidence(linelist,
          date_index = date_hospitalisation,
          groups = c(age_cat, hospital),
          interval = "weeks")

plot(hospitalisation_week,
     fill = age_cat)

```
</br>
</details>









