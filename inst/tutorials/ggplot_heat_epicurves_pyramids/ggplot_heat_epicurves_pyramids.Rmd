---
title: "Applied Epi - Heat plots, epicurves, pyramids"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
    css: css/css_custom.css
    theme: "paper"
runtime: shiny_prerendered
description: >
  Learn how to get started with R and RStudio, and how to import a dataset
---

<!-- NOTES: To edit images, edit them in the "images" folder that lives NEXT TO THE RMD FILE -->


<!-- Add JavaScript code for making the exercise code larger -->
<script language="JavaScript" src="js/exercise-font-size.js"></script>

```{r setup, include=FALSE}
library(gradethis)
library(etude)
library(learnr)
library(dplyr)
library(flair)
library(ggplot2)
library(lubridate)
library(forcats)
library(fontawesome)
library(scales)
library(stringr)
library(apyramid)
library(incidence2)
library(viridis)
library(janitor)
library(tidyr)

# set options for exercises and checking ---------------------------------------
gradethis::gradethis_setup()

learnr::tutorial_options(exercise.timelimit = 60)
    # exercise.checker = gradethis::grade_learnr) 
    # alternatively, submitr::null_code_checker

# event recorder ---------------------------------------------------------------
# see https://github.com/dtkaplan/submitr/blob/master/R/make_a_recorder.R

tutorial_options(exercise.eval = FALSE)  # pre-evaluate exercises

# new_recorder <- function(tutorial_id, tutorial_version, user_id, event, data) {
#     cat(
#       tutorial_id, 
#       " (v", tutorial_version, "); ",
#       format(Sys.time(), "%Y-%M%-%D %H:%M:%S %Z"), "; ",
#       user_id, "; ",
#       event, "; ",
#       data$label, "; ",
#       data$answers, "; ",
#       data$code, "; ",
#       data$correct, "\n", sep = "",
#       
#       file = here::here("event_records", "learnr_basics.txt"),
#       append = TRUE)
# }

#options(tutorial.event_recorder = new_recorder)
```


```{r, include=FALSE}
# hide non-exercise code chunks ------------------------------------------------
knitr::opts_chunk$set(echo = FALSE)
```

```{r, include=FALSE}
# data prep --------------------------------------------------------------------
combined <- rio::import(system.file("dat/linelist_combined_20141201.rds", package = "introexercises"))



# Create hospital weeks for heat plot
#####################################
# count cases by hospital-week
hospital_weeks_raw <- combined %>%
  count(hospital, week_onset) 

# create longer dataset of all possible hospital-weeks
expanded <- hospital_weeks_raw %>% 
  select(hospital, week_onset) %>%
  tidyr::expand(., week_onset, hospital)

# merge so that all hospital-weeks are represented in the data
hospital_weeks <- hospital_weeks_raw %>%      
  right_join(expanded) %>%                            
  mutate(n = replace_na(n, 0)) %>% 
  filter(week_onset >= ymd("2014-06-15"))






count_data <- combined %>% 
  group_by(hospital, date_hospitalisation) %>% 
  summarize(n_cases = dplyr::n()) %>% 
  ungroup()

hospitalisation_week <- incidence(combined,
          date_index = date_hospitalisation,
          interval = "weeks")

demo_agg <- combined %>% 
  count(age_cat, gender, name = "cases") %>% 
  pivot_wider(
    id_cols = age_cat,
    names_from = gender,
    values_from = cases) %>% 
  rename(`missing_gender` = `NA`)

aggregate_data <- demo_agg %>% 
  pivot_longer(
    col = c(female, male, missing_gender),            # cols to elongate
    names_to = "gender",                # name for new col of categories
    values_to = "counts") %>%           # name for new col of counts
  mutate(
    gender = na_if(gender, "missing_gender")) # convert "missing_gender" to NA

```




## Introduction to R for Applied Epidemiology and Public Health


### Welcome

Welcome to the live course "Introduction to R for applied epidemiologists", offered by [Applied Epi](www.appliedepi.org) - a nonprofit organisation that offers open-source tools, training, and support to frontline public health practitioners.  

```{r, eval = TRUE, echo = FALSE, out.width = "25%"}
knitr::include_graphics("images/logo.png")
```

### Heat plots, epidemic curves, and pyramids  

This exercise focuses on learning how to code and customize more advanced plots such as heat plots, epidemic curves and age/sex demographic pyramids. We will be building on what you have learned previously from tidyverse and ggplot2 to produce these.

This will involve using previously explored aspects such as:  

* `ggplot()`  
* Pipe chains `%>%`  
* Themes (e.g. `theme_minimal()`, `theme_bw()`)  
* Custom axis scales (e.g. `scale_y_continuous()`)  
* New functions such as `geom_tile()` for heat plots and `geom_histogram()` for epidemic curves, and `age_pyramid()` (from {apyramid}) for age/sex pyramids  


### Format

This exercise will guide you through a set of tasks.  
*You should perform these tasks in RStudio and on your local computer*.  

#### Getting Help  

There are several ways to get help:  

1) Look for the "helpers" (see below)
2) Ask your live course instructor/facilitator for help  
3) Ask a colleague or other participant in the course for tips  
4) Post a question in [Applied Epi Community](www.community.appliedepi.org) in the category for questions about Applied Epi Training  

Here is what those "helpers" will look like:

<!--
NOTE: Below is the hint (all within details tags collapsed)
-->
<details>

<summary style='text-decoration: underline; color: darkgreen;'>`r fontawesome::fa("lightbulb", fill = "gold")` Click to read a hint</summary>
</br>

Here you will see a helpful hint!  

</br>
</details>

<!--
NOTE: Below is the solution (all within details tags collapsed)
-->

<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>

```{r eval = F, echo=T}
linelist %>% 
  filter(
    age > 25,
    district == "Bolo"
  )
```

Here is more explanation about why the solution works.  

</br>
</details>
<!--
NOTE: End of solution
-->


#### Quiz questions  

Please complete the quiz questions that you encounter throughout the tutorial. **Answering will help you** to comprehend the material, and will also help us to improve the exercises for future students.  

To practice, please answer the following questions:  


```{r quiz-use-helper, echo=F}
quiz(
  question_radio("When should I view the red 'helper' code?",
    answer("After trying to write the code myself", correct = TRUE),
    answer("Before I try coding", correct = FALSE),
    correct = "Reviewing best-practice code after trying to write yourself can help you improve",
    incorrect = "Please attempt the exercise yourself, or use the hint, before viewing the answer."
  )
)
```


```{r quiz-anxious, echo = FALSE}
question_numeric(
 "How anxious are you about beginning this tutorial - on a scale from 1 (least anxious) to 10 (most anxious)?",
 answer(10, message = "Try not to worry, we will help you succeed!", correct = T),
 answer(9, message = "Try not to worry, we will help you succeed!", correct = T),
 answer(8, message = "Try not to worry, we will help you succeed!", correct = T),
 answer(7, message = "Try not to worry, we will help you succeed!", correct = T),
 answer(6, message = "Ok, we will get there together", correct = T),
 answer(5, message = "Ok, we will get there together", correct = T),
 answer(4, message = "I like your confidence!", correct = T),
 answer(3, message = "I like your confidence!", correct = T),
 answer(2, message = "I like your confidence!", correct = T),
 answer(1, message = "I like your confidence!", correct = T),
 allow_retry = TRUE,
 correct = "Thanks for sharing. ",
 min = 1,
 max = 10,
 step = 1
)
```



#### Icons  

You will see these icons throughout the exercises:

Icon  |Meaning
------|--------------------
`r fontawesome::fa("eye", fill = "darkblue")`|Observe  
`r fontawesome::fa("exclamation", fill = "red")`|Alert!  
`r fontawesome::fa("pen", fill = "brown")`|An informative note  
`r fontawesome::fa("terminal", fill = "black")`|Time for you to code!  
`r fontawesome::fa("window-restore", fill = "darkgrey")`|Change to another window  
`r fontawesome::fa("bookmark", fill = "orange")`|Remember this for later  




## Learning objectives  

In this exercise you will:  

* Practice reading R documentation for functions  
* Learn to make heat plots  
* Learn to make epidemic curves  
* Learn to make age/sex pyramids  





## Refresh your memory  

First, let us refresh ourselves on the basics of **ggplot2**!

```{r quiz1}
quiz(
  question("Where are dynamic aesthetics placed in ggplot code?",
    allow_retry = TRUE,
    answer("inside aes()", correct = T),
    answer("outside aes()", message = "dynamic assignments means the aesthetic is mapped to a column in the data, and the presentation can vary for each row. These must be done inside 'mapping = aes()'")
  ),
  question("Are static aesthetics in the initial ggplot() call inherited by subsequent geoms?",
    allow_retry = TRUE,
    answer("No", correct = TRUE),
    answer("Yes", message = "No, for example if you set the size of points equal to 3, the lines will not be size 3 as well.")
  ),
  question("Are dynamic aesthetics in the initial ggplot() call inherited by subsequent geoms?",
    allow_retry = TRUE,
    answer("No", message = "Yes they are, for example, assigning wt_kg to the X-axis is inherited by all the subsequent geoms."),
    answer("Yes", correct = TRUE)
  ),
    question("Should adjustments to the theme be made before or after setting one of the default themes?",
    allow_retry = TRUE,
    answer("before", message = "A complete/default theme will override all previous micro adjustments to the theme"),
    answer("after", correct = TRUE)
  ),
  question("Which of the following are prebuilt themes in ggplot",
    allow_retry = TRUE,
    answer("theme_bw()", correct = TRUE),
    answer("theme_classic()", correct = TRUE),
    answer("theme_red()"),
    answer("scale_color_brewer()")
  ),
  question("How would you hide a legend in ggplot?",
    allow_retry = TRUE,
    answer("theme(legend.title = 'element.blank()')"),
    answer("theme(legend.position = 'right')"),
    answer("theme(legend.position(none))"),
    answer("theme(legend.position = 'none')", correct = TRUE)
  ),
  question("How would you set your legend to appear in the centre of your graph?",
    answer("theme(legend.position = 'middle')"),
    answer("theme(legend.position =  c(0.5,0.5))", correct = TRUE)
  )
)
```

Great, now we have refreshed our memory with a quiz, we will start on our first topic, *heat plots*.





## Preparation  

Open your R project and run your entire "ebola_analysis.R" script, so that you are able to use the data frame `combined`.  

This will involve running all the parts of your R script, including to import data, clean, perform joins, and create the `combined` dataset.  

If you encounter errors, remember that you saved the `combined` data frame in your "data/clean" subfolder, so you can import it again directly to continue with the exercise (be sure to clean up your script errors later).  






## Heat plots

Heat plots, also called "heat tiles", are useful visualizations when trying to display **3 variables** (x-axis, y-axis and fill).  

For instance, you may want to look at a breakdown of how many cases were reported by week across several hospitals, to get an idea of how the epidemic has progressed in several places. Let's see how this works.  

Let's say that we have a data frame called `hospital_weeks`, which has the following columns:  

```{r, eval=T, echo=T}
head(hospital_weeks)    # print the first 6 rows
```

This data is in "long" format, and every possible hospital-week has a row.  



Go ahead and create this dataset in your RStudio using this code below. Understanding this code will not be covered here (try our advanced course in data management), but in essence it uses `count()` to get case counts by week, then creates a dataset with all possible hospital-weeks, and then joins them together.  

```{r, echo = T, eval = T, message = F}
# count cases by hospital-week
hospital_weeks_raw <- combined %>%
  count(hospital, week_onset) 

# create longer dataset of all possible hospital-weeks
expanded <- hospital_weeks_raw %>% 
  select(hospital, week_onset) %>%
  tidyr::expand(., week_onset, hospital)

# merge so that all hospital-weeks are represented in the data
hospital_weeks <- hospital_weeks_raw %>%      
  right_join(expanded) %>%                            
  mutate(n = replace_na(n, 0)) %>% 
  filter(week_onset >= ymd("2014-06-15"))

```

### Review documentation  

`r fontawesome::fa("eye", fill = "darkblue")` Take a few minutes to review the documentation for the funtion `geom_tile()`, which is from {ggplot2}. You can access this by either:  

1) Entering `?geom_tile` in the Console, or  
2) Click to the "Help" pane (lower-right) and entering `geom_tile` in the search bar  



### Basic heat plot  

What `ggplot()` code would you write to create a heat plot that:  

* Has the week of onset on the x-axis  
* Has the hospital name on the y-axis  
* Is colored by the number of onsets in that week?

<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r eval = F, echo=T}
ggplot(data = hospital_weeks) +
  geom_tile(aes(x = week_onset, y = hospital, fill = n))
```
</br>
</details>


```{r quiz1-2}
quiz(
  question("Which hospital reported the most cases with onset in September?",
    allow_retry = TRUE,
    answer("SMMH"),
    answer("Port Hospital", correct = T),
    answer("Military Hospital"),
    answer("Central Hospital"),
    answer("Unknown")
  ),
    question("Which hospital reported the highest case fatality ratio?",
    allow_retry = TRUE,
    answer("SMMH", message = "It is not possible to know the case fatality ratio from this plot"),
    answer("Port Hospital", message = "It is not possible to know the case fatality ratio from this plot"),
    answer("Military Hospital", message = "It is not possible to know the case fatality ratio from this plot"),
    answer("Central Hospital", message = "It is not possible to know the case fatality ratio from this plot"),
    answer("Unknown", correct = T)
    )
)
```




### Customising your heat plot

`r fontawesome::fa("terminal", fill = "black")` The plot is nice, but let us do a dew more things to refine the presentation:  

1) Modify `hospital_weeks` to create a new data frame: `hospital_weeks_adjusted`. In this data frame, ensure that the `NA` values in the column `hospital` are re-coded as "Missing" *and* this column is class "factor" with the levels in this order : "Central Hospital", "Military Hospital", "Port Hospital", "SMMH", "Other", "Missing".  


<!--
NOTE: Below is the hint (all within details tags collapsed)
-->
<details>

<summary style='text-decoration: underline; color: darkgreen;'>`r fontawesome::fa("lightbulb", fill = "gold")` Click to read a hint</summary>
</br>

Within `mutate()` commands, use the {forcats} package and its function `fct_explicit_na()` to re-define the column `hospital` to convert `NA` to "(Missing)" (this also converts the column to class "factor"). In another mutate command, use the function `fct_relevel()` to adjust the ordering of the levels.  

If you need a refresher on how to change `NA` values in factor columns, and how to reorder, checkout the R Handbook chapter on [factors](https://www.epirhandbook.com/en/factors.html?q=factor#factors).  

</br>
</details>


<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, echo=T, eval=F}
hospital_weeks_adjusted <- hospital_weeks %>% 
  mutate(hospital = fct_explicit_na(hospital),
         hospital = fct_relevel(hospital, "Central Hospital", "Military Hospital", "Port Hospital", "SMMH", "Other", "(Missing)"))
```
</br>
</details>



2) In the ggplot *of the new adjust data frame*, change the color scheme to a diverging color scale. Provide a scale one that extends from "skyblue" at low values to "tomato" at high values.  


<!--
NOTE: Below is the hint (all within details tags collapsed)
-->
<details>

<summary style='text-decoration: underline; color: darkgreen;'>`r fontawesome::fa("lightbulb", fill = "gold")` Click to read a hint</summary>
</br>

Add `scale_fill_gradient()` to the `ggplot()` command. See the help documentation with `?scale_fill_gradient` to understand the arguments.  

</br>
</details>


<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, echo=T, eval=F}
ggplot(data = hospital_weeks) +
  geom_tile(aes(x = week_onset, y = hospital, fill = n))+
  scale_fill_gradient(low = "skyblue", high = "tomato")

```
</br>
</details>



3) The default x-axis ticks show each month. Change these to efficiently show every two weeks (not show any duplicate information).


<!--
NOTE: Below is the hint (all within details tags collapsed)
-->
<details>

<summary style='text-decoration: underline; color: darkgreen;'>`r fontawesome::fa("lightbulb", fill = "gold")` Click to read a hint</summary>
</br>

Add `scale_x_date()` and set `date_breaks = "2 weeks"`, and `labels = scales::label_date_short()`  

</br>
</details>


4) Make the labels for the axes and legend more presentable.  

<!--
NOTE: Below is the hint (all within details tags collapsed)
-->
<details>

<summary style='text-decoration: underline; color: darkgreen;'>`r fontawesome::fa("lightbulb", fill = "gold")` Click to read a hint</summary>
</br>

Adjust the `labs()`. Recall that the legend title in this case is edited with `fill = ` because it was created by the fill.  

</br>
</details>



Below is all the solution code together:  

<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r eval = F, echo=T}
# Edit the dataset
hospital_weeks_adjusted <- hospital_weeks %>% 
  mutate(hospital = fct_explicit_na(hospital),
         hospital = fct_relevel(hospital, "Central Hospital", "Military Hospital", "Port Hospital", "SMMH", "Other", "(Missing)"))

# Plot with adjustments
ggplot(data = hospital_weeks) +
  geom_tile(aes(x = week_onset, y = hospital, fill = n))+
  scale_fill_gradient(low = "skyblue", high = "tomato")+
  scale_x_date(date_breaks = "2 weeks",
               labels = scales::label_date_short())+
  labs(x = "Week of symptom onset",
       y = "Hospital",
       fill = "Number of\nweekly cases")+
  theme_minimal()

```
</br>
</details>








### Setting up the data, creating and customising a heat plot

Note that to make the heat plot using `geom_tile()`, you had to provide a data frame with *counts* - aggregated data (not a linelist). There are ways to create heat plots from linelist data (see `geom_density()` functions) but those will not be covered today.  

Now that you are familiar with the plotting syntax, we will move to an exercise where you create the counts data frame and further customize the plot display.  


`r fontawesome::fa("terminal", fill = "black")` Try to do the following on your own. It will be challenging, but this is good exposure to intermediate-level R programming.  

1) Use `combined` to create a new data frame named `age_outcome_summary`.  
  * First, drop any rows with  `NA` values by piping to `drop_na(gender, age_cat)`.  
  * Then, use `group_by()` and `summarise()` to show summary counts for each unique combination (group) of `age_cat` and `gender`.  
  * In addition to case counts, include a column showing the number of rows in each group whose `outcome` is equal to "Death".  
  * Finally, include a column calculating with the proportion in each group equal to "Death".  


<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, eval = F, echo = T}
# make new data frame summarizing age, gender, and deaths
age_outcome_summary <- combined %>%
  drop_na(gender, age_cat) %>%         # remove any NA values
  group_by(age_cat, gender) %>%        # group rows by age-gender groups
  summarise(                           # begin creating new summary columns
    n = n(),
    n_death = sum(outcome == "Death",  # sum the number of rows where outcome is Death
                  na.rm = TRUE),
    pct_death = n_death / n)           # create proportion dead in the group
```
</br>
</details>



2) Now, create a heat plot using this new data frame. Make the tiles be filled (color) according to the percent of those that have an outcome of "Death" as broken down by `gender` and `age_cat` in your data frame.  

If possible, do the following as well:  

* Clean up the axis names to "Age category", "Gender" and the legend title to `"Percent of\ncases fatal"`  
* Using the **viridis** package (`scale_fill_viridis()`) and pick a color scheme option (e.g. `option = "B"`), and set the scale `limits = c(0, 1)` to align with the proportions.  
* Add `geom_text()` to display the percent on each tile. Try this first by reading the documentation for `geom_text`.  
  * To display as percents, you will need to edit `labels = scales::percent()` within `aes()`. Round to one decimal place with `accuracy = 0.1`.  
  
<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, eval = F, echo = T}
# make plot
ggplot(data = age_outcome_summary,            # use new data frame
       mapping = aes(x = gender,              # gender on x-axis
                     y = age_cat,             # age category on y-axis
                     fill = pct_death)) +     # fill (color) is shaded by the proportion dead
  geom_tile() +                               # display data as tiles  
  scale_fill_viridis(                         # adjust colors scale
    option = "B",                             # pick any option
    limits = c(0, 1)) +                       # set the limits to go from 0 to 1
  geom_text(                                  # add text over the tiles
    mapping = aes(
      label = scales::percent(                # show percents instead of proportions
        pct_death,
        accuracy = 0.1)))+
  labs(x = "Gender",                          # add labels
       y = "Age categories",
       fill = "Percent of\ncases fatal") +
  scale_fill_continuous(                      # adjust the values displayed in the legend
    labels = scales::percent)                 # to be percents (not proportions)



```
</br>
</details>



###
```{r quiz2}
quiz(
  question("Who has the highest proportion of 'Death' as a gender and age category?",
           answer("Male and 20-29", correct = TRUE),
           answer("Female and 20-29"),
           answer("Male and 50-59"),
           answer("Female and 40-49")
           ),
  question("Which gender has the oldest ages?",
           answer("Female"),
           answer("Male", correct = TRUE)
           )
)
```


Ok, good job! You have managed to build summary datasets for a heat plot and then customize the plot so that you can analyze the information.  

Even if you did not know how to do all of those edits to the ggplot, the purpose of that task was to expose you to a new plot and customization possibilities.  

You can always find sample code in the Heat Plots chapter of the [Epi R Handbook](https://www.epirhandbook.com/en/heat-plots.html?q=heat%20plot#heat-plots), and become more well-practiced later.  



## Epi curves

An epidemic curve (also known as an “epi curve”) is a core epidemiological chart typically used to visualize the temporal pattern of illness onset among a cluster or epidemic of cases.

Analysis of the epicurve can reveal temporal trends, outliers, the magnitude of the outbreak, the most likely time period of exposure, time intervals between case generations, and can even help identify the mode of transmission of an unidentified disease (e.g. point source, continuous common source, person-to-person propagation).

We are going to build epidemic curves with {ggplot2}, which allows for advanced customizability. There is another option, the {incidence2} package as described in the [Epi R Handbook](https://epirhandbook.com/en/epidemic-curves.html#epicurves-with-incidence2-package), which is perhaps more simple but less customizeable.  




<!-- ### incidence2 -->

<!-- In order to explore epicurves, we are going to use the object `count_data`. Explore the dataframe to look at the dimensions, column names and example data. -->

<!-- From this, we can use the function `incidence()` from **incidence2** to produce a simple epicurve.  -->

<!-- `r fontawesome::fa("terminal", fill = "black")` Can you read the documentation of `incidence()` (`?incidence`) in order to produce a simple incidence object for the column `date_hospitalisation` with an interval of 1 week? Can you then assign this to an object `hospitalisation_week`? -->

<!-- <details> -->
<!-- <summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary> -->
<!-- </br> -->
<!-- ```{r, eval = F, echo = T} -->
<!-- hospitalisation_week <- incidence(combined, -->
<!--           date_index = date_hospitalisation, -->
<!--           interval = "weeks") -->
<!-- ``` -->
<!-- </br> -->
<!-- </details> -->

<!-- Okay, now that you have made the object its time to plot. In it's simplest form, you can just type type `plot(hospitalisation_week)` -->
<!-- ```{r, eval = T, echo = F} -->
<!-- plot(hospitalisation_week) -->
<!-- ``` -->

<!-- However, we may want to customise this output. In particular, we are not displaying potentially useful information found within `combined`, such as age categories.  -->

<!-- `r fontawesome::fa("terminal", fill = "black")` Can you reform the `incidence()` object `hospitalisation_week` to additionally have the groups `hospital` and `age_cat`, with the incidence set to every 2 weeks? Remember you always consult the help (`?incidence`) if you need more information!  -->

<!-- * Once you have done this, can you plot the object using `plot()` and "fill" using `age_cat` in order to see how the epidemic curves differ by age category? -->

<!-- <details> -->
<!-- <summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary> -->
<!-- </br> -->
<!-- ```{r, eval = F, echo = T} -->
<!-- hospitalisation_week <- incidence(combined, -->
<!--           date_index = date_hospitalisation, -->
<!--           groups = c(age_cat, hospital), -->
<!--           interval = "2 weeks") -->

<!-- plot(hospitalisation_week, -->
<!--      fill = age_cat) -->
<!-- ``` -->
<!-- </br> -->
<!-- </details> -->


<!-- By default, the epi curves categories are stacked to show the overall incidence. Sometimes we would want to show them separately as it can be easier to see individual trends among groups, to do this we add the argument `stack = FALSE`. -->

<!-- `r fontawesome::fa("terminal", fill = "black")` Can you update this to re-plot `hospitalisation_week`, showing with the fill of `age_cat` side-by-side (NOT stacked)? -->

<!-- <details> -->
<!-- <summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary> -->
<!-- </br> -->
<!-- ```{r, eval = F, echo = T} -->
<!-- plot(hospitalisation_week, -->
<!--      fill = age_cat, -->
<!--      stack = FALSE) -->
<!-- ``` -->
<!-- </br> -->
<!-- </details> -->

<!-- Now there is a lot of very useful information here, but it would also be helpful to show how these epi curves of different ages differ by hospital. In order to do this, we will need more than one plot. -->

<!-- Rather than manually specifying each hospital using a filter, we can use the function `facet_plot` from **incidence2** to produce individual plots for each hospital. -->

<!-- `r fontawesome::fa("terminal", fill = "black")` After looking at the help for `facet_plot`, can you plot `hospitalisation_week` with stacked bars, filled by `age_cat` and faceted by `hospital`? -->

<!-- <details> -->
<!-- <summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary> -->
<!-- </br> -->
<!-- ```{r, eval = F, echo = T} -->
<!-- facet_plot(hospitalisation_week, -->
<!--      fill = age_cat, -->
<!--      facets = hospital) -->
<!-- ``` -->
<!-- </br> -->
<!-- </details> -->

<!-- Great job, now that you have mastered the **incidence2** package, we will move onto using **ggplot2** in order to plot our incidence curves. -->

### {ggplot2} epicurves

As you have been through several exercises using {ggplot2}, you are now familiar with the syntax and customization it allows (themes, labels, axes, etc). 

In its most basic form, plotting epidemic curves in {ggplot2} is a case of using the ggplot function `geom_histogram()`. However, there are 3 main things to watch out for:  

* The histogram bins (how the data are grouped by time unit)  
* Scales for axes and their labels
* Themes for the plot appearance

### Simple bins  

`r fontawesome::fa("terminal", fill = "black")` Can you make a simple histogram from the data frame `combined` which shows the incidence of `date_onset` using 5-day intervals? The histogram "binwidth" can be specified as a number (a static aesthetic) to `binwidth = `. Also, clean up the labels and use `theme_bw()`.  

<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, eval = F, echo = T}
ggplot(data = combined, mapping = aes(x = date_onset)) +
    geom_histogram(binwidth = 5) +
    labs(x = "Date of onset", y = "Incidence") +
    theme_bw()
```
</br>
</details>



### Defining manual bins  

Calculating incidence via binwidths works if we do not care about the specific days of the week used (the bins will start at the first case), and if we do not care about months (because months can be 28, 29, 30 or 31 days!).  

But as epidemiologists and public health practitioners, we usually care about the details. We typically need to produce an epidemic curve that adheres to very particular specifications. For example, cases binned by month, or by a 7-day week that starts on a particular day.  

In these cases, **instead of using `binwidth = `, we specify `breaks = `.**  

What does `breaks =` expect as a value? It expects a *vector* of dates to use as breaks (cut-points). 

How to make a vector of dates? We know that we can create a vector using `c()`, for example `c(54, 22, 89)` or `c("Paris", "Delhi", "Kigali")`.  

We can even make a vector of dates: `c(ymd("2014-06-15"), ymd("2014-06-22"), ymd("2014-06-29"))` But this would be have to be a very long code to include *all* the weekly break points throughout this outbreak!  

Instead we can use the {base} function `seq.Date()` to automatically create a *sequence* of dates between a `from = ` value, to a `to = ` value, and in increments specified to `by = `. You can specify `by` values such as "day", "week", "month", etc.  

The sequence below uses dates of the first and last case onsets.  

```{r, echo=T, eval=T}
seq.Date(from = ymd("2014-05-06"),
         to = ymd("2014-11-28"),
         by = "week")
```

So, we could write an epicurve command like the below:  

```{r, echo=T, eval=T, warning=F, message=F}
ggplot(data = combined, aes(x = date_onset))+
  geom_histogram(
    breaks = seq.Date(
      from = ymd("2014-05-06"),
      to = ymd("2014-11-28"),
      by = "week")) +
  labs(x = "Date of onset", y = "Incidence") +
  theme_bw()
```

Now we are confident that the breaks are using 7-day intervals from the first case to the last case.  

But typically we want the intervals to start on **Mondays** (or some other day), so we add `floor_date()` and it's companion `ceiling_date()` :  

```{r, echo=T, eval=T}
# Monday BEFORE the earliest case
floor_date(ymd("2014-05-06"), unit = "week", week_start = 1)

# Monday AFTER the last case
ceiling_date(ymd("2014-11-28"), unit = "week", week_start = 1)
```

And so now we can create a vector of Mondays from before the earliest case, to after the latest case.  

```{r,echo=T, eval=T}
# Sequence of Mondays from before earliest case, to after latest case
seq.Date(from = floor_date(ymd("2014-05-06"), unit = "week", week_start = 1),
         to =   ceiling_date(ymd("2014-11-28"), unit = "week", week_start = 1),
         by =   "week")
```

Finally, what happens if our data are refreshed or updated with new data? Those static dates in our code will not be current!  

Let's replace them with `min()` and `max()` applied to the column `combined$date_onset`.  

As this is not a {dplyr} pipe, we need to specify the data frame and column with the `$` index operator. Don't forget that these two functions need `na.rm=TRUE` to remove missing values.  

```{r, echo=T, eval=T}
seq.Date(from = floor_date(min(combined$date_onset, na.rm=T), unit = "week", week_start = 1),
         to =   ceiling_date(max(combined$date_onset, na.rm=T), unit = "week", week_start = 1),
         by =   "week")
```

In this way, we have made our code more *dynamic*. Dynamic code will be important if our dataset is refreshed/updated, so you want all the plots and tables to update automatically.  


Finally, the easiest way to insert this `seq.Date()` vector into the `ggplot()` command is by saving it in advance, with a name. So the command becomes two separate commands:  

```{r, echo=T, eval=F}
# Define and save the vector
ebola_weeks <- seq.Date(
  from = floor_date(min(combined$date_onset, na.rm=T), unit = "week", week_start = 1),
  to =   ceiling_date(max(combined$date_onset, na.rm=T), unit = "week", week_start = 1),
  by =   "week")

```


Now if you run just `ebola_weeks`, the vector is returned/printed. So we can provide `ebola_weeks` to the `breaks = ` argument of `geom_histogram()`.  

One final change before we finish is that we also add `closed = "left"` to `geom_histogram()` which sets the bars to also count the cases reported on the break days themselves.    

```{r, echo=T, eval=F}
# Define and save the vector
ebola_weeks <- seq.Date(
  from = floor_date(min(combined$date_onset, na.rm=T), unit = "week", week_start = 1),
  to =   ceiling_date(max(combined$date_onset, na.rm=T), unit = "week", week_start = 1),
  by =   "week")


# Run the plot, using the vector
ggplot(data = combined, aes(x = date_onset)) +
  geom_histogram(breaks = ebola_weeks, closed = "left") +
  labs(x = "Date of onset", y = "Incidence") +
  theme_bw()

```

Compare this plot to the histogram printed in the exercise above (7-days, no specified breaks). Do you see any small differences in how the cases have been binned? (look at the beginning of the epidemic).  

The above can seem like a lot of work to just produce a list of dates! But think of the control that you have over the output. And, now that you have this code it will be easy to modify. (Also this is all in the Epi R Handbook chapter on Epidemic Curves).

### Monthly epidemic curve  

`r fontawesome::fa("terminal", fill = "black")` Now it is your turn. Copy the code and make a new epidemic curve in which the histogram bin breaks are by *month* from the month-start prior to the first case, until the month-start after the last case. 

Once you have done this, adjust the code so that the `fill` in the bars is by hospital, and the x-axis labels appear every month.  


<!--
NOTE: Below is the hint (all within details tags collapsed)
-->
<details>

<summary style='text-decoration: underline; color: darkgreen;'>`r fontawesome::fa("lightbulb", fill = "gold")` Click to read a hint</summary>
</br>

As we want the values to be aggregated by calendar month, do the following:  

* Set the `unit =` to "month" in the two {lubridate} functions `floor_date()` and `ceiling_date()` and remove the `week_start` arguments (check `?floor_date` for details).  
* Change the `by = ` argument of `seq.Date()` to "month"  
* Change the name of the vector `ebola_weeks` to `ebola_months`, and change it in the `ggplot()` command too.  

* To set the fill, put `fill = hospital` in the aesthetic mappings  
* To adjust the x-axis labels, do the following within `scale_x_date()`:  
  * set `labels = date_label_easy()`  
  * set `date_breaks = "months"`  
  
</br>
</details>


<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, eval = F, echo = T}
# define and save the vector (by month)
ebola_months <- seq.Date(
  from = floor_date(min(combined$date_onset, na.rm=T), unit = "month"),
  to =   ceiling_date(max(combined$date_onset, na.rm=T), unit = "month"),
  by =   "month")

# run the plot with monthly breaks, and fill
ggplot(data = combined, aes(x = date_onset, fill = hospital)) +
  geom_histogram(breaks = ebola_months, closed = "left") +
  scale_x_date(
    date_breaks = "months",
    labels = scales::label_date_short())+
  labs(x = "Date of onset", y = "Incidence") +
  theme_bw()
```
</br>
</details>




### Facets  

It may be difficult to read this epicurve and to understand the case trends from each hospital.  

*Faceting* the plots means creating "small-multiple" (mini plots) for each unique value in a column (e.g. `hospital`).  

You create facets by adding `facet_wrap()` to the ggplot. Within this function, write a tilde ~ and then the name of the column, for example:  

```{r, echo=T, eval=F}
facet_wrap(~gender)
```

**Now, create facets based on `hospital` for your epidemic curve.**  


<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, eval = F, echo = T}
ggplot(data = combined, aes(x = date_onset, fill = hospital)) +
  geom_histogram(breaks = ebola_months, closed = "left") +
  scale_x_date(
    date_breaks = "months",
    labels = scales::label_date_short())+
  labs(x = "Date of onset", y = "Incidence") +
  theme_bw()+
  facet_wrap(~hospital)
```
</br>
</details>


There are MANY other adjustments that you can make to your epidemic curve made with {ggplot2}. Many of them are outlined in the [Epidemic curves chapter of the Epi R Handbook](https://epirhandbook.com/en/epidemic-curves.html#epidemic-curves).  













## Age pyramids

Age pyramids are a useful way of illustrating demographics, and can be customised in a variety of different ways. For our purposes, we will be using the function `age_pyramid()` from the **apyramid** package.  


### **apyramid**

The function `age_pyramid()` is fairly simple, in that it produces high quality age pyramids with relatively few arguments. 

It is good to practice trying to use a function by reading the documentation and trying to write the command yourself.  


`r fontawesome::fa("eye", fill = "darkblue")` Look up the documentation for the function (`?age_pyramid`). Review the arguments, and the examples.  

`r fontawesome::fa("terminal", fill = "black")` Now create an age pyramid using the `combined` data frame and the `age_cat` categories, that is split by `gender`.  





<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, eval = F, echo = T}
age_pyramid(data = combined,
            age_group = "age_cat", #note that the column must be enclosed in quotation marks (" ")
            split_by = "gender")  #note that the column must be enclosed in quotation marks (" ")
```
</br>
</details>

You can also plot the values by proportion, rather than count, and include a column for missing data.

`r fontawesome::fa("terminal", fill = "black")` Can you now, after reading the instructions, create an age pyramid of gender that includes missing (`NA`) values and plots the proportion?

<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, eval = F, echo = T}
age_pyramid(data = combined,
            age_group = "age_cat", #note that the column must be enclosed in quotation marks (" ")
            split_by = "gender",
            proportional = TRUE,
            na.rm = FALSE) 
```
</br>
</details>



### Counts

In the previous example, the data is in a linelist format, where each row is a unique observation. However, you may be given data that is already aggregated into counts.

Just to practice, create this dataset `demo_wide_counts` in your RStudio by running the following command:  

```{r, echo=T, eval=T}
# Creates the object demo_agg
#############################
demo_wide_counts <- structure(list(
  age_cat = structure(c(1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, NA),
                      .Label = c("0-9", "10-19", "20-29", "30-39", "40-49", "50-59", "60-69", "70+"), class = "factor"),
  female = c(149L, 104L, 55L, 15L, 4L, 1L, NA, NA, NA),
  male = c(96L, 80L, 65L, 39L, 19L, 5L, 5L, 1L, NA),
  missing_gender = c(5L, 4L, 4L, 2L, NA, NA, 1L, NA, 26L)),
  row.names = c(NA, -9L),
  class = c("tbl_df", "tbl", "data.frame"))
```

It should look like this:  


```{r, eval=T, echo=TRUE}
demo_wide_counts
```

To be acceptable to `age_pyramid()` the data must be in "long" format, so first, you would need to *pivot longer* so that the gender information is in one column (remember tidy data!) and the counts are in one column.  

You could use this command:  

```{r, echo=T, eval=T}
demo_long_counts <- demo_wide_counts %>% 
  pivot_longer(
    col = c(female, male, missing_gender),    # cols to elongate
    names_to = "gender",                      # name for new col of categories
    values_to = "counts") %>%                 # name for new col of counts
  mutate(
    gender = na_if(gender, "missing_gender")) # convert "missing_gender" to NA
```

Which results in: 
```{r, echo=T, eval=T}
demo_long_counts
```

Now, use your knowledge of the `age_pyramid()` documentation to adjust the plotting command to accept counts.  

<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, eval = F, echo = T, warning=F, message=F}
age_pyramid(data = demo_long_counts,
            age_group = "age_cat", 
            split_by = "gender",
            count = "counts")
```
</br>
</details>


### Adding ggplot to age pyramids  

Finally, you can add ( + ) ggplot commands to {apyramid} age pyramids. For example, the code below adds labels and adjusts the color scale:  


```{r, message=F, warning=F, echo=T, eval=T}
# Age pyramid with ggplot modifications
age_pyramid(
     data = combined,
     age_group = "age_cat",
     split_by = "gender",
     proportional = TRUE,
     show_midpoint = FALSE)+
     
  theme_minimal()+
     
  scale_fill_brewer(type = "qual", palette = 2)+
  
  labs(title = str_glue("Age and gender of confirmed cases"),
       x = "Proportion of all cases",
       y = "Age group",
       caption = str_glue("Ebola outbreak"),
       fill = "Gender")
```



## End  

Congratulations! You have finished the exercise on heat plots, epidemic curves, and age/sex pyramids! These are some challenging plots that you have been making!  






<!-- ### **ggplot2** -->

<!-- Using `ggplot()` to build the age pyramid allows for much more flexibility, but requires more effort and an understanding of how `ggplot()` works. -->

<!-- There are several steps to constructing the age pyramid: -->

<!-- 1) Within the ggplot(), we need to create **two** histograms using the numeric age column. -->
<!-- 2) We generate the incidence values through the specifying `y = ..count..` -->
<!-- 3) One of these must have its counts converted to _negative_ values. This creates the "pyramid" with the value of 0 in the middle. Negative values are created by multiplying the column by -1. -->
<!-- 4) The command `coord_flip()` switches the X and Y axes is required to flip the axes and create the pyramid. -->
<!-- 5) Finally, the count-axis value labels must be altered so they appear as "positive" on both sides of the pyramid, despite the underlying values on one side being negative. -->

<!-- Considering you have already practiced using `geom_histogram()` for the epi curves, and given the instructions above. Can you re-create the a simple age pyramid, with age breaks ever 5 years, below? -->

<!-- ```{r, echo = F, eval = T} -->
<!-- # begin ggplot -->
<!--   ggplot(mapping = aes(x = age, fill = gender)) + -->

<!--   # female histogram -->
<!--   geom_histogram(data = combined %>% filter(gender == "female"), -->
<!--                  breaks = seq(0, 85, 5), -->
<!--                  colour = "white") + -->

<!--   # male histogram (values converted to negative) -->
<!--   geom_histogram(data = combined %>% filter(gender == "male"), -->
<!--                  breaks = seq(0,85,5), -->
<!--                  mapping = aes(y = ..count..*(-1)), -->
<!--                  colour = "white") + -->

<!--   # flip the X and Y axes -->
<!--   coord_flip() + -->

<!--   # adjust counts-axis scale -->
<!--   scale_y_continuous(limits = c(-100, 100), -->
<!--                      breaks = seq(-100,100,25), -->
<!--                      labels = abs(seq(-100, 100, 25)))+ -->
<!--   labs(y = "Count", x = "Age", fill = "Gender") -->
<!-- ``` -->

<!-- <details> -->
<!-- <summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary> -->
<!-- </br> -->
<!-- ```{r, eval = F, echo = T} -->
<!-- # begin ggplot -->
<!--   ggplot(mapping = aes(x = age, fill = gender)) + -->

<!--   # female histogram -->
<!--   geom_histogram(data = combined %>% filter(gender == "female"), -->
<!--                  breaks = seq(0, 85, 5), -->
<!--                  colour = "white") + -->

<!--   # male histogram (values converted to negative) -->
<!--   geom_histogram(data = combined %>% filter(gender == "male"), -->
<!--                  breaks = seq(0,85,5), -->
<!--                  mapping = aes(y = ..count..*(-1)), -->
<!--                  colour = "white") + -->

<!--   # flip the X and Y axes -->
<!--   coord_flip() + -->

<!--   # adjust counts-axis scale -->
<!--   scale_y_continuous(limits = c(-100, 100), -->
<!--                      breaks = seq(-100,100,25), -->
<!--                      labels = abs(seq(-100, 100, 25)))+ -->
<!--   labs(y = "Count", x = "Age", fill = "Gender") -->
<!-- ``` -->
<!-- </br> -->
<!-- </details> -->

<!-- Great, now what if we want to produce the percentages? In order to do this, we will need to group the data and use `mutate()` in order to produce new columns. -->

<!-- This part is a a lot more complicated than if we were using the **apyramid** function `age_pyramid()` -->

<!-- In order to create the percent values, we need to employ `mutate()` and the tidyselect helper function `case_when`. For example, this would be the command to generate the percent -->

<!-- ```{r, eval = F, echo = T} -->
<!--  mutate(percent = round(100*(counts / sum(counts, na.rm=T)), digits = 1),  -->
<!--          percent = case_when( -->
<!--             gender == "f" ~ percent, -->
<!--             gender == "m" ~ -percent,     # convert male to negative -->
<!--             TRUE          ~ NA_real_))    # NA val must by numeric as well -->
<!-- ``` -->

<!-- Can you add in the parts before this to assign aggregate values to an object called `pyramid_data` from `combined`? Once you've done this, can you produce the previous age pyramid, but showing percentages instead of counts, adjust axis scale and labels as necessary? -->

<!-- Remember, as in when creating an epi curve that has already been aggregated, you should use `geom_bar()` or `geom_col()` rather than `geom_histogram()` -->


<!-- <details> -->
<!-- <summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary> -->
<!-- </br> -->
<!-- ```{r, eval = F, echo = T} -->
<!-- # create dataset with proportion of total -->
<!-- pyramid_data <- combined %>% -->
<!--   count(age_cat, -->
<!--         gender, -->
<!--         name = "counts") %>%  -->
<!--   ungroup() %>%                 # ungroup so percents are not by group -->
<!--   mutate(percent = round(100*(counts / sum(counts, na.rm=T)), digits = 1),  -->
<!--          percent = case_when( -->
<!--             gender == "female" ~ percent, -->
<!--             gender == "male" ~ -percent,     # convert male to negative -->
<!--             TRUE          ~ NA_real_))    # NA val must by numeric as well -->


<!-- # begin ggplot -->
<!--   ggplot() + -->

<!--   # histogram -->
<!--   geom_col(data = pyramid_data, -->
<!--            mapping = aes( -->
<!--              x = age_cat, -->
<!--              y = percent, -->
<!--              fill = gender),          -->
<!--            colour = "white") +       # white around each bar -->

<!--   # flip the X and Y axes -->
<!--   coord_flip() + -->

<!--   # adjust counts-axis scale -->
<!--   scale_y_continuous(limits = c(-25, 25), -->
<!--                      breaks = seq(-25,25,25), -->
<!--                      labels = abs(seq(-25, 25, 25)))+ -->
<!--   labs(y = "Percent (%)", x = "Age", fill = "Gender") -->
<!-- ``` -->
<!-- </br> -->
<!-- </details> -->
