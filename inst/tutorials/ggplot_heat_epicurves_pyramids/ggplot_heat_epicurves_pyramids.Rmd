---
title: "Applied Epi - Heat plots, epicurves, and pyramids"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
library(ggplot2)
library(tidyverse)
library(viridis)
library(lubridate)
library(apyramid)
library(incidence2)

knitr::opts_chunk$set(echo = FALSE)
linelist <- rio::import(system.file("dat/linelist_combined_20141201.rds", package = "introexercises"))

linelist$hospital <- factor(linelist$hospital)

#Create an easy heatmap dataset
hospital_week_raw <- linelist %>%
  group_by(hospital, week_onset) %>%
  summarise(n = n())

expanded_weeks <- hospital_week_raw %>% 
  select(hospital, week_onset) %>%
  ungroup() %>%
  tidyr::expand(., week_onset, hospital)

hospital_week_expanded <- hospital_week_raw %>%      
  right_join(expanded_weeks) %>%                            
  mutate(n = replace_na(n, 0))  

hospital_week <- subset(hospital_week_expanded, week_onset >= "2014-06-15")

count_data <- linelist %>% 
  group_by(hospital, date_hospitalisation) %>% 
  summarize(n_cases = dplyr::n()) %>% 
  ungroup()

hospitalisation_week <- incidence(linelist,
          date_index = date_hospitalisation,
          interval = "weeks")

demo_agg <- linelist %>% 
  count(age_cat, gender, name = "cases") %>% 
  pivot_wider(
    id_cols = age_cat,
    names_from = gender,
    values_from = cases) %>% 
  rename(`missing_gender` = `NA`)

aggregate_data <- demo_agg %>% 
  pivot_longer(
    col = c(female, male, missing_gender),            # cols to elongate
    names_to = "gender",                # name for new col of categories
    values_to = "counts") %>%           # name for new col of counts
  mutate(
    gender = na_if(gender, "missing_gender")) # convert "missing_gender" to NA


```

# Advanced ggplot2 - Heatmaps, Epi curves and Age pyramids

## Welcome

Welcome to the advanced ggplot2 module where we will be learning how to code and customise more advanced plots such as heatmaps, epi curves and age pyramids. We will be building on what you have learned previously from tidyverse and ggplot2 to produce these.

This will involve using previously explored aspects such as `ggplot()`, pipe chains `%>%`, themes (e.g. `theme_minimal()`, `theme_bw()`), custom axis scales (e.g. `scale_y_continuous()`) and new functions such as `geom_tile()` for heatmaps, `incidence` (from **incidence2**) and `geom_histogram()` for epi curves, and `age_pyramid` (from **apyramid**) for age pyramids.

But first, let us refresh ourselves on the basics of **ggplot2**!

```{r quiz1}
quiz(
  question("Where are dynamic aesthetics placed in ggplot code?",
    answer("inside aes()", correct = T),
    answer("outside aes()")
  ),
  question("Are static aesthetics in the initial ggplot() call inherited by subsequent geoms?",
    answer("No", correct = TRUE),
    answer("Yes")
  ),
  question("Are dynamic aesthetics in the initial ggplot() call inherited by subsequent geoms?",
    answer("No"),
    answer("Yes", correct = TRUE)
  ),
    question("Should adjustments to the theme be made before or after setting one of the default themes?",
    answer("before"),
    answer("after", correct = TRUE)
  ),
  question("Which of the following are prebuilt themes in ggplot",
    answer("theme_bw()", correct = TRUE),
    answer("theme_classic()", correct = TRUE),
    answer("theme_red()"),
    answer("scale_color_brewer()")
  ),
  question("How would you hide a legend in ggplot?",
    answer("theme(legend.title = 'element.blank()')"),
    answer("theme(legend.position = 'right')"),
    answer("theme(legend.position(`none`))"),
    answer("theme(legend.position = 'none')", correct = TRUE)
  ),
  question("How would you set your legend to appear in the centre of your graph?",
    answer("theme(legend.position = 'middle')"),
    answer("theme(legend.position =  c(0.5,0.5))", correct = TRUE)
  )
)
```

Great, now we have refreshed our memory with a quiz, we will start on our first topic, *heatmaps*.

## Heatmaps

Heatmaps, also called heat plots and heat tiles, are useful visualizations when trying to display 3 variables (x-axis, y-axis and fill). For instance, you might want to look at a breakdown of how many cases were reported by week across a hospitals to get an idea of how the epidemic is/has progressed.

We have a dataset called `hospital_week`, which has columns labelling the hospital, the week of onset and the number of these in the week. Use `head()` to look at the data.

`r fontawesome::fa("terminal", fill = "black")` With the aid of the help function `?geom_tile` can you create a heatmap that has the week of onset on the x-axis, the hospital on the y-axis and is colored by the number of onsets in that week?

<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r eval = F, echo=T}
ggplot(data = hospital_week) +
  geom_tile(aes(x = week_onset, y = hospital, fill = n))
```
</br>
</details>

### Customising your heatmap

`r fontawesome::fa("terminal", fill = "black")` Great job, but there are still a few things we can do to refine this plot.

* Can you create a new object, `hospital_week_adjusted` where the NA values in `hospital` are recoded as "Missing", and the factors are re-ordered as "Central Hospital", "Military Hospital", "Port Hospital", "SMMH", "Other", "Missing".
* Change the color scheme to a diverging colour scale, could you provide one that goes from "skyblue" at low values to "tomato" at high values
* The axis and fill labels should be made more presentable
* The default x-axis ticks show every month, can you change these to every two weeks, and only display the day and month.

This will require a mix of refactoring the dataset, and adjusting your **ggplot** function. If you need a refresher on how to change `NA` values in factor columns, and how to reorder, checkout the R Handbook chapter on [factors](https://www.epirhandbook.com/en/factors.html?q=factor#factors).

<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r eval = F, echo=T}
hospital_week_adjusted <- hospital_week %>%
  mutate(hospital = fct_explicit_na(hospital, "Missing"),
         hospital = fct_relevel(hospital, rev(c("Central Hospital", "Military Hospital", "Port Hospital", "SMMH", "Other", "Missing"))))

ggplot(data = hospital_week_adjusted) +
  geom_tile(aes(x = week_onset, y = hospital, fill = n)) +
  scale_fill_gradient(low = "skyblue", high = "tomato") +
  labs(x = "Week onset", y = "Hospital", fill = "Number of patients with\nsymptom onset") +
  scale_x_date(date_breaks = "2 weeks", 
               date_labels = "%d %b")
```
</br>
</details>

Now you have got the hang of heatmaps and some basic customisation, we are going to move onto a harder exercise where you create the dataframe from scratch and customize the display.

Can you do the following

* Create a new object, `age_outcome_summary`, where you summarise `linelist` in order to output the percent of those in each `outcome` category when it is grouped by `age_cat` and `gender`
* Drop any `NA` values
* Once this is done, create a heatmap that is coloured by the percent of those that have an outcome of "Death" when broken down by `gender` and `age_cat`
* Clean up the axis names to "Age category", "Gender" and label to "Percent of cases fatal"
* Using the **viridis** package (`scale_fill_viridis()`) and pick a colour scheme, and set the scale limits to go from 0 to 100
* Display the percent, rounded to 1 decimal place 

<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, eval = F, echo = T}
age_outcome_summary <- linelist %>%
  drop_na(gender, age_cat) %>% #Remove the NA values
    group_by(age_cat, gender, outcome) %>% #Group by in order to summarise later
    summarise(n = n()) %>%        #Count the number in each grouping
    mutate(percent = n/sum(n) * 100) #Multiply by 100 to make the proportion into a percentage

ggplot(data = subset(age_outcome_summary, outcome == "Death")) +                 #Subset to only those with the outcome death
  geom_tile(aes(x = gender, y = age_cat, fill = percent)) +                         #Set up the mapping
  scale_fill_viridis(option = "B", limits = c(0, 100)) +                           #Choose any of the options, and set the limits to go from 0 to 100
  labs(x = "Gender", y = "Age categories", fill = "Proportion of cases fatal") +
  geom_text(
    aes(x = gender, y = age_cat, label = round(percent, 1)))


```
</br>
</details>

###
```{r quiz2}
quiz(
  question("What do you notice? Who has the lowest proportion of 'Death' as a gender and age category?",
    answer("Male and 60-69"),
    answer("Female and 0-9"),
    answer("Male and 20-29"),
    answer("Female and 40-49", correct = TRUE)
    ),
  question("Who has the highest proportion of 'Death' as a gender and age category?",
           answer("Male and 20-20", correct = TRUE),
           answer("Female and 20-29"),
           answer("Male and 50-59"),
           answer("Female and 40-49")
           ),
  question("Which gender has the oldest ages?",
           answer("Female"),
           answer("Male", correct = TRUE)
           )
)
```


Great work, you have managed to build datasets for heatmap plotting and customize these plots to produce interesting graphics you can then analyze. As with all aspects of R and ggplot, there are numerous additional ways of coding and customizing your plots to edit almost every specification you can think of. For further reading, please see the R Epidemiologists Handbook chapter on [heatmaps](https://www.epirhandbook.com/en/heat-plots.html?q=heat%20plot#heat-plots).

## Epi curves

An epidemic curve (also known as an “epi curve”) is a core epidemiological chart typically used to visualize the temporal pattern of illness onset among a cluster or epidemic of cases.

Analysis of the epicurve can reveal temporal trends, outliers, the magnitude of the outbreak, the most likely time period of exposure, time intervals between case generations, and can even help identify the mode of transmission of an unidentified disease (e.g. point source, continuous common source, person-to-person propagation).

Here we are going to look at two different ways of learning how to make epicurves

* The **incidence2** package, which can produce an epi curve with simple commands
* The **ggplot2** package, which allows for advanced customizability via more complex commands

Firstly, we will look at the **incidence2** package.

### incidence2

In order to explore epicurves, we are going to use the object `count_data`. Explore the dataframe to look at the dimensions, column names and example data.

From this, we can use the function `incidence()` from **incidence2** to produce a simple epicurve. 

Can you read the documentation of `incidence()` (`?incidence`) in order to produce a simple incidence object for the column `date_hospitalisation` with an interval of 1 week? Can you then assign this to an object `hospitalisation_week`?

<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, eval = F, echo = T}
hospitalisation_week <- incidence(linelist,
          date_index = date_hospitalisation,
          interval = "weeks")
```
</br>
</details>

Okay, now that you have made the object its time to plot. In it's simplest form, you can just type type `plot(hospitalisation_week)`
```{r, eval = T, echo = F}
plot(hospitalisation_week)
```

However, we may want to customise this output. In particular, we are not displaying potentially useful information found within `linelist`, such as age categories. Can you reform the `incidence()` object `hospitalisation_week` to additionally have the groups `hospital` and `age_cat`, with the incidence set to every 2 weeks? Remember you always consult the help (`?incidence`) if you need more information! 

Once you have done this, can you plot the object using `plot()` and "fill" using `age_cat` in order to see how the epidemic curves differ by age category?

<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, eval = F, echo = T}
hospitalisation_week <- incidence(linelist,
          date_index = date_hospitalisation,
          groups = c(age_cat, hospital),
          interval = "2 weeks")

plot(hospitalisation_week,
     fill = age_cat)
```
</br>
</details>


By default, the epi curves categories are stacked to show the overall incidence. Sometimes we would want to show them separately as it can be easier to see individual trends among groups. 

By default, when you plot an incidence object, the bars are stacked with `stack = TRUE`, can you update this to re-plot `hospitalisation_week`, showing with the fill of `age_cat` side-by-side (NOT stacked)?

<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, eval = F, echo = T}
plot(hospitalisation_week,
     fill = age_cat,
     stack = FALSE)
```
</br>
</details>

Now there is a lot of very useful information here, but it would also be helpful to show how these epi curves of different ages differ by hospital. In order to do this, we will need more than one plot.

Rather than manually specifying each hospital using a filter, we can use the function `facet_plot` from **incidence2** to produce individual plots for each hospital.

After looking at the help for `facet_plot`, can you plot `hospitalisation_week` with stacked bars, filled by `age_cat` and faceted by `hospital`?

<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, eval = F, echo = T}
facet_plot(hospitalisation_week,
     fill = age_cat,
     facets = hospital)
```
</br>
</details>

Great job, now that you have mastered the **incidence2** package, we will move onto using **ggplot2** in order to plot our incidence curves.
### ggplot2

As you have been through several exercises using **ggplot2**, you are now familiar with the syntax and customization it allows (themes, labels, axes, etc). 

Plotting epi curves in **ggplot2** is a case of using the function `geom_histogram()`, however, unlike in **incidence2** we also need to manually control the aggregation and intervals of time. There are three main things to watch out for

* Bins, these are specific "break" points that must be specified (time points, so if the unit was days and `binwidth = 7` then it would have an interval of a week)
* Scales for axes and their labels
* Themes for the plot appearance

`r fontawesome::fa("terminal", fill = "black")` Can you make a simple histogram from the dataset `linelist` which shows the incidence of `date_onset` every 5 days? Remember to specify the bindwith correctly, supply a theme and clean up the labels!

<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, eval = F, echo = T}
ggplot(data = linelist) +
    geom_histogram(aes(x = date_onset),
                   bindwidth = 5) +
  labs(x = "Date of onset", y = "Incidence") +
  theme_bw()
```
</br>
</details>

This approach of calculating incidence through specifying binwidths is a good approach if we do not care about the specific day of the week we use, and if we don't want to specify by a changing value (i.e. months can be 28, 29, 30 or 31 days!).

If we want to make sure that we calculate the incidence according a specific breakdown (i.e. by month, 7 day week starting on a particular day etc) then *instead* of using `binwidth = `, we specify `breaks = `.

This allows us to use specific dates by which to aggregate our data. For instance, the function `seq.Date()` can specify between two dates break periods of values such as days, weeks, months, etc.

`r fontawesome::fa("terminal", fill = "black")` Can you create a vector of dates that goes from the first month that there is data for `date_onset`, till the last month, by months. Once you've done this, can you create an epi curve which also fills in the bars by hospital and has x-axis breaks every month?

Hint: As we want the values to be aggregated by calendar month, we can use functions such as `min()` and `max()` to find the first date and last dates, and then from the **lubridate** package, the functions `floor_date()` and `ceiling_date()` to ensure we encompass the entire month (when correctly specified, check `?floor_date` for details).

<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, eval = F, echo = T}
month_break <- seq.Date(from = floor_date(min(linelist$date_onset, na.rm = T), "month"),      #Here we use min to find the lowest value, and then floor_date() from the lubridate package in order to get the 1st of the month
                        to = ceiling_date(max(linelist$date_onset, na.rm = T), "month"), #Here we work out the last month and using ceiling_date to get the month above it in order to fill in the values correctly
                        by = "months")

ggplot(data = linelist) +
    geom_histogram(aes(x = date_onset, fill = hospital),
                   breaks = month_break) +
  labs(x = "Date of onset", y = "Incidence") +
  theme_bw() +
  scale_x_date(breaks = "months")
```
</br>
</details>

## Age pyramids

Age pyramids are a useful way of illustrating demographics, and can be customised in a variety of different ways. For our purposes, we will be using the function `age_pyramid()` from the **apyramid** package and `geom_histogram()` from **ggplot2**.

### **apyramid**

`age_pyramid()` is a fairly simple function that produces high quality age pyramids with relatively few arguments. 

`r fontawesome::fa("terminal", fill = "black")` Can you look up the function (`?age_pyramid`) and then create an age pyramid from `linelist` of `age_category` that is split by `gender`?

<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, eval = F, echo = T}
age_pyramid(data = linelist,
            age_group = "age_cat", #note that the column must be enclosed in quotation marks (" ")
            split_by = "gender")  #note that the column must be enclosed in quotation marks (" ")
```
</br>
</details>

You can also plot the values by proportion, rather than count, and include a column for missing data.

`r fontawesome::fa("terminal", fill = "black")` Can you now, after reading the instructions, create an age pyramid of gender that includes missing (`NA`) values and plots the proportion?

<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, eval = F, echo = T}
age_pyramid(data = linelist,
            age_group = "age_cat", #note that the column must be enclosed in quotation marks (" ")
            split_by = "gender",
            proportional = TRUE,
            na.rm = FALSE)  #note that the column must be enclosed in quotation marks (" ")
```
</br>
</details>

Currently we are assuming that the data is in a linelist format, where each row is a unique observation. However, you may be given data that is already aggregated.

This is easily dealt with in **apyramid** by simply specifying `count = `, where the column that contains the count values is specified.

`r fontawesome::fa("terminal", fill = "black")` Knowing this, and checking with the function help if needed, can you create an age pyramid that is split by gender from the aggregate dataset `aggregate_data`?

<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, eval = F, echo = T}
age_pyramid(data = linelist,
            age_group = "age_cat", 
            split_by = "gender",
            count = "counts")
```
</br>
</details>

Note the data format, which one of these is it?

```{r quiz3}
quiz(
  question("",
    answer("long format", correct = T),
    answer("wide format")
  ))
```

### **ggplot2**

Using `ggplot()` to build the age pyramid allows for much more flexibility, but requires more effort and an understanding of how `ggplot()` works.

There are several steps to constructing the age pyramid:

1) Within the ggplot(), we need to create **two** histograms using the numeric age column. 
2) One of these must have its counts converted to _negative_ values. This creates the "pyramid" with the value of 0 in the middle. Negative values are created by multiplying the column by -1.
3) The command `coord_flip()` switches the X and Y axes is required to flip the axes and create the pyramid.
4) Finally, the count-axis value labels must be altered so they appear as "positive" on both sides of the pyramid, despite the underlying values on one side being negative.

Considering you have already practiced using `geom_histogram()` for the epi curves, and given the instructions above. Can you re-create the a simple age pyramid, with age breaks ever 5 years, below?

```{r, echo = F, eval = T}
# begin ggplot
  ggplot(mapping = aes(x = age, fill = gender)) +
  
  # female histogram
  geom_histogram(data = linelist %>% filter(gender == "female"),
                 breaks = seq(0, 85, 5),
                 colour = "white") +
  
  # male histogram (values converted to negative)
  geom_histogram(data = linelist %>% filter(gender == "male"),
                 breaks = seq(0,85,5),
                 mapping = aes(y = ..count..*(-1)),
                 colour = "white") +
  
  # flip the X and Y axes
  coord_flip() +
  
  # adjust counts-axis scale
  scale_y_continuous(limits = c(-100, 100),
                     breaks = seq(-100,100,25),
                     labels = abs(seq(-100, 100, 25)))+
  labs(y = "Count", x = "Age", fill = "Gender")
```

<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, eval = F, echo = T}
# begin ggplot
  ggplot(mapping = aes(x = age, fill = gender)) +
  
  # female histogram
  geom_histogram(data = linelist %>% filter(gender == "female"),
                 breaks = seq(0, 85, 5),
                 colour = "white") +
  
  # male histogram (values converted to negative)
  geom_histogram(data = linelist %>% filter(gender == "male"),
                 breaks = seq(0,85,5),
                 mapping = aes(y = ..count..*(-1)),
                 colour = "white") +
  
  # flip the X and Y axes
  coord_flip() +
  
  # adjust counts-axis scale
  scale_y_continuous(limits = c(-100, 100),
                     breaks = seq(-100,100,25),
                     labels = abs(seq(-100, 100, 25)))+
  labs(y = "Count", x = "Age", fill = "Gender")
```
</br>
</details>

Great, now what if we want to produce the percentages? In order to do this, we will need to group the data and use `mutate()` in order to produce new columns.

This part is a a lot more complicated than if we were using the **apyramid** function `age_pyramid()`

In order to create the percent values, we need to employ `mutate()` and the tidyselect helper function `case_when`. For example, this would be the command to generate the percent

```{r, eval = F, echo = T}
 mutate(percent = round(100*(counts / sum(counts, na.rm=T)), digits = 1), 
         percent = case_when(
            gender == "f" ~ percent,
            gender == "m" ~ -percent,     # convert male to negative
            TRUE          ~ NA_real_))    # NA val must by numeric as well
```

Can you add in the parts before this to assign aggregate values to an object called `pyramid_data` from `linelist`? Once you've done this, can you produce the previous age pyramid, but showing percentages instead of counts, adjust axis scale and labels as necessary?

Remember, as in when creating an epi curve that has already been aggregated, you should use `geom_bar()` or `geom_col()` rather than `geom_histogram()`


<details>
<summary style='text-decoration: underline; color: red;'>`r fontawesome::fa("check", fill = "red")`Click to see a solution (try it yourself first!)</summary>
</br>
```{r, eval = F, echo = T}
# create dataset with proportion of total
pyramid_data <- linelist %>%
  count(age_cat,
        gender,
        name = "counts") %>% 
  ungroup() %>%                 # ungroup so percents are not by group
  mutate(percent = round(100*(counts / sum(counts, na.rm=T)), digits = 1), 
         percent = case_when(
            gender == "female" ~ percent,
            gender == "male" ~ -percent,     # convert male to negative
            TRUE          ~ NA_real_))    # NA val must by numeric as well


# begin ggplot
  ggplot() +
  
  # histogram
  geom_col(data = pyramid_data,
           mapping = aes(
             x = age_cat,
             y = percent,
             fill = gender),         
           colour = "white") +       # white around each bar

  # flip the X and Y axes
  coord_flip() +
  
  # adjust counts-axis scale
  scale_y_continuous(limits = c(-25, 25),
                     breaks = seq(-25,25,25),
                     labels = abs(seq(-25, 25, 25)))+
  labs(y = "Percent (%)", x = "Age", fill = "Gender")
```
</br>
</details>
